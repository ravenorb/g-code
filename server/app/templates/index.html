<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HK Parser Upload</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
        background: #f8fafc;
        color: #0f172a;
      }
      h1,
      h2 {
        margin-bottom: 0.5rem;
      }
      .card {
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0.5rem;
      }
      th,
      td {
        border: 1px solid #e2e8f0;
        padding: 0.5rem;
        text-align: left;
      }
      th {
        background: #f1f5f9;
      }
      .badge {
        display: inline-block;
        padding: 0.15rem 0.35rem;
        border-radius: 4px;
        font-size: 0.85rem;
        color: #fff;
      }
      .badge.error {
        background: #ef4444;
      }
      .badge.warning {
        background: #f59e0b;
      }
      .hidden {
        display: none;
      }
      .visually-hidden {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }
      .sheet-canvas {
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        background: #ffffff;
        margin-top: 0.5rem;
      }
      .code-box {
        background: #0f172a;
        color: #e2e8f0;
        padding: 0.75rem;
        border-radius: 6px;
        overflow-y: auto;
        max-height: 360px;
        white-space: pre;
      }
      .order-list {
        list-style: decimal;
        padding-left: 1.5rem;
        margin: 0.75rem 0 0;
      }
      .order-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem 0.75rem;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        background: #ffffff;
        margin-bottom: 0.5rem;
        cursor: grab;
      }
      .order-item.dragging {
        opacity: 0.6;
        background: #f1f5f9;
      }
      .order-hint {
        font-size: 0.9rem;
        color: #475569;
        margin-top: 0.5rem;
      }
      .order-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-top: 0.75rem;
      }
      .top-actions {
        flex-wrap: wrap;
      }
      .action-button {
        padding: 0.4rem 0.85rem;
        border-radius: 6px;
        border: 1px solid #1e293b;
        background: #1e293b;
        color: #ffffff;
        cursor: pointer;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .action-button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .order-status {
        font-size: 0.9rem;
        color: #475569;
      }
    </style>
  </head>
  <body>
    <h1>HK Parser Upload</h1>
    <div class="card">
      <div class="order-actions top-actions">
        <button id="reset-cut-order" class="action-button" type="button" disabled>Reset</button>
        <button id="download-cut-order" class="action-button" type="button" disabled>Create MPF from Cut Order</button>
        <button id="upload-new-file" class="action-button" type="button">Upload New File</button>
        <span id="cut-order-status" class="order-status"></span>
      </div>
      <p id="status" class="hidden"></p>
    </div>

    <form id="upload-form" class="visually-hidden">
      <label for="file">Select G-code file:</label>
      <input type="file" id="file" name="file" accept=".gcode,.txt,.mpf,.nc,.tap" required />
      <label for="attachment">Link PDF (optional):</label>
      <input type="file" id="attachment" name="attachment" accept=".pdf,application/pdf" />
      <label for="description">Description (optional):</label>
      <textarea id="description" name="description" rows="3" placeholder="Add any notes about the file..."></textarea>
      <button type="submit">Upload & Validate</button>
    </form>

    <div class="card hidden" id="results-card">
      <p id="summary"></p>
      <p id="storage"></p>
      <div id="diagnostics-section" class="hidden">
        <h2>Diagnostics</h2>
        <table id="diagnostics-table">
          <thead>
            <tr>
              <th>Severity</th>
              <th>Message</th>
              <th>Line</th>
              <th>Code</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h2 id="sheet-layout">Sheet Layout</h2>
      <div class="order-actions">
        <button id="preview-sheet-skeleton" class="action-button" type="button" disabled>
          Preview Sheet Skeleton
        </button>
      </div>
      <p id="sheet-info" class="hidden"></p>
      <canvas id="sheet-canvas" class="sheet-canvas" width="1440" height="840"></canvas>

      <h2>Cut Order (Beta)</h2>
      <p class="order-hint">
        Drag parts to reorder the cut sequence. The order is saved locally in your browser and used to build the
        reordered MPF.
      </p>
      <ol id="parts-order" class="order-list"></ol>

      <h2>Original File Code</h2>
      <pre id="raw-code" class="code-box"></pre>
    </div>

    <script>
      const form = document.getElementById("upload-form");
      const statusEl = document.getElementById("status");
      const resultsCard = document.getElementById("results-card");
      const summaryEl = document.getElementById("summary");
      const storageEl = document.getElementById("storage");
      const diagnosticsSection = document.getElementById("diagnostics-section");
      const diagnosticsBody = document.querySelector("#diagnostics-table tbody");
      const rawCode = document.getElementById("raw-code");
      const sheetInfo = document.getElementById("sheet-info");
      const sheetCanvas = document.getElementById("sheet-canvas");
      const previewSkeletonButton = document.getElementById("preview-sheet-skeleton");
      const partsOrderList = document.getElementById("parts-order");
      const resetCutOrderButton = document.getElementById("reset-cut-order");
      const downloadCutOrderButton = document.getElementById("download-cut-order");
      const cutOrderStatus = document.getElementById("cut-order-status");
      const uploadNewFileButton = document.getElementById("upload-new-file");
      const fileInput = document.getElementById("file");
      const attachmentInput = document.getElementById("attachment");
      const descriptionInput = document.getElementById("description");
      let lastJobId = null;
      let lastJob = null;
      let sheetHotspots = [];
      let lastSheetSnapshot = {
        setup: null,
        parts: [],
      };
      const cutOrderState = {
        originalOrder: [],
        savedOrder: [],
        pendingOrder: [],
      };

      uploadNewFileButton.addEventListener("click", () => {
        form.classList.remove("visually-hidden");
        fileInput.value = "";
        attachmentInput.value = "";
        descriptionInput.value = "";
        fileInput.focus();
      });

      fileInput.addEventListener("change", () => {
        if (!fileInput.files.length) return;
        statusEl.classList.remove("hidden");
        statusEl.textContent = "Ready to upload. Optionally attach a PDF, add a description, then click Upload.";
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!fileInput.files.length) return;

        statusEl.classList.remove("hidden");
        statusEl.textContent = "Uploading and validating...";
        resultsCard.classList.add("hidden");
        diagnosticsBody.innerHTML = "";
        rawCode.textContent = "";
        sheetHotspots = [];
        lastJobId = null;
        cutOrderStatus.textContent = "";
        resetCutOrderButton.disabled = true;
        downloadCutOrderButton.disabled = true;

        const formData = new FormData();
        formData.append("file", fileInput.files[0]);
        if (attachmentInput.files.length) {
          formData.append("attachment", attachmentInput.files[0]);
        }
        formData.append("description", descriptionInput.value);

        try {
          const response = await fetch("/upload", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            const detail = await response.text();
            throw new Error(detail || "Validation failed");
          }

          const data = await response.json();
          lastJob = data;
          lastJobId = data.job_id;
          renderSummary(data);
          renderStorage(data);
          renderDiagnostics(data);
          renderRawCode(data.raw_program || []);
          renderPartsOrder(data.parts || []);
          renderSheet(data.setup, getOrderedParts(data.parts || [], cutOrderState.pendingOrder));
          cutOrderStatus.textContent = "";

          statusEl.textContent = "Validation completed.";
          resultsCard.classList.remove("hidden");
        } catch (err) {
          statusEl.textContent = `Error: ${err.message}`;
        } finally {
          fileInput.value = "";
          attachmentInput.value = "";
        }
      });

      function renderSummary(data) {
        summaryEl.textContent = `Job: ${data.job_id} — Errors: ${data.summary.errors}, Warnings: ${data.summary.warnings}, Lines: ${data.summary.lines}`;
      }

      function renderStorage(data) {
        const storageBits = [];
        if (data.stored_path) storageBits.push(`Stored: ${data.stored_path}`);
        if (data.meta_path) storageBits.push(`Meta: ${data.meta_path}`);
        if (data.link_meta_path) storageBits.push(`Link: ${data.link_meta_path}`);
        if (data.linked_files && data.linked_files.length) {
          const linkedList = data.linked_files.map((item) => item.filename).join(", ");
          storageBits.push(`Linked files: ${linkedList}`);
        }
        if (data.uploaded_at) storageBits.push(`Uploaded: ${data.uploaded_at}`);
        storageEl.textContent = storageBits.join(" | ");
      }

      function renderDiagnostics(diagnostics) {
        diagnosticsBody.innerHTML = "";
        const hasIssues = Boolean(lastJob?.summary?.errors || lastJob?.summary?.warnings);
        if (!hasIssues) {
          diagnosticsSection.classList.add("hidden");
          return;
        }
        diagnosticsSection.classList.remove("hidden");
        if (!diagnostics.length) {
          diagnosticsBody.innerHTML = `<tr><td colspan="4">No diagnostics</td></tr>`;
          return;
        }
        diagnostics.forEach((diag) => {
          const row = document.createElement("tr");
          const badge = `<span class="badge ${diag.severity}">${diag.severity}</span>`;
          row.innerHTML = `
            <td>${badge}</td>
            <td>${diag.message}</td>
            <td>${diag.line ?? ""}</td>
            <td>${diag.code ?? ""}</td>
          `;
          diagnosticsBody.appendChild(row);
        });
      }

      function renderRawCode(lines) {
        if (!lines.length) {
          rawCode.textContent = "No program lines available.";
          return;
        }
        rawCode.textContent = lines.join("\n");
      }

      function renderSheet(setup, parts) {
        const ctx = sheetCanvas.getContext("2d");
        ctx.clearRect(0, 0, sheetCanvas.width, sheetCanvas.height);
        sheetInfo.classList.add("hidden");
        sheetHotspots = [];
        sheetCanvas.style.cursor = parts.length ? "pointer" : "default";
        lastSheetSnapshot = { setup, parts };
        updateSkeletonButtonState(setup);

        if (!setup || !setup.sheetX || !setup.sheetY) {
          sheetInfo.textContent = "No HKINI sheet size found for this file.";
          sheetInfo.classList.remove("hidden");
          return;
        }

        const padding = 24;
        const sheetWidth = setup.sheetX;
        const sheetHeight = setup.sheetY;
        const scale = Math.min(
          (sheetCanvas.width - padding * 2) / sheetWidth,
          (sheetCanvas.height - padding * 2) / sheetHeight
        );
        const originX = padding;
        const originY = padding;
        const drawWidth = sheetWidth * scale;
        const drawHeight = sheetHeight * scale;

        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 2;
        ctx.strokeRect(originX, originY, drawWidth, drawHeight);

        const palette = ["#2563eb", "#16a34a", "#f97316", "#8b5cf6", "#0ea5e9"];
        const flipParts180 = true;
        const transformPoint = (x, y) => {
          if (!flipParts180) {
            return { x, y };
          }
          return { x: sheetWidth - x, y: sheetHeight - y };
        };
        const toCanvas = ({ x, y }) => ({
          x: originX + x * scale,
          y: originY + (sheetHeight - y) * scale,
        });
        ctx.font = "12px Arial";
        parts.forEach((part, index) => {
          const color = palette[index % palette.length];
          const contours = part.plot_points || [];
          let minX = null;
          let minY = null;
          let maxX = null;
          let maxY = null;

          if (contours.length) {
            contours.flat().forEach((point) => {
              const baseX = (part.anchor_x ?? 0) + point[0];
              const baseY = (part.anchor_y ?? 0) + point[1];
              const { x, y } = transformPoint(baseX, baseY);
              minX = minX === null ? x : Math.min(minX, x);
              minY = minY === null ? y : Math.min(minY, y);
              maxX = maxX === null ? x : Math.max(maxX, x);
              maxY = maxY === null ? y : Math.max(maxY, y);
            });
          }

          if (minX === null || minY === null || maxX === null || maxY === null) {
            if (part.anchor_x == null || part.anchor_y == null) {
              return;
            }
            const { x, y } = transformPoint(part.anchor_x, part.anchor_y);
            minX = x - 5;
            maxX = x + 5;
            minY = y - 5;
            maxY = y + 5;
          }

          let boxX = originX + minX * scale;
          let boxY = originY + (sheetHeight - maxY) * scale;
          let boxW = (maxX - minX) * scale;
          let boxH = (maxY - minY) * scale;
          const minBoxSize = 12;
          if (boxW < minBoxSize) {
            boxX -= (minBoxSize - boxW) / 2;
            boxW = minBoxSize;
          }
          if (boxH < minBoxSize) {
            boxY -= (minBoxSize - boxH) / 2;
            boxH = minBoxSize;
          }

          ctx.strokeStyle = color;
          ctx.lineWidth = 1.5;
          ctx.setLineDash([]);
          contours.forEach((contour) => {
            if (contour.length < 2) return;
            ctx.beginPath();
            contour.forEach((point, pointIndex) => {
              const baseX = (part.anchor_x ?? 0) + point[0];
              const baseY = (part.anchor_y ?? 0) + point[1];
              const canvasPoint = toCanvas(transformPoint(baseX, baseY));
              const x = canvasPoint.x;
              const y = canvasPoint.y;
              if (pointIndex === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            });
            ctx.stroke();
          });

          ctx.fillStyle = color;
          ctx.fillText(`#${index + 1} (P${part.part_number})`, boxX + 4, boxY + 14);

          sheetHotspots.push({
            x: boxX,
            y: boxY,
            width: boxW,
            height: boxH,
            url: `/jobs/${lastJobId}/parts/${part.part_number}/view`,
          });
        });

        sheetInfo.textContent = `Sheet: ${sheetWidth} × ${sheetHeight} — Click a part to open.`;
        sheetInfo.classList.remove("hidden");
      }

      function updateSkeletonButtonState(setup) {
        previewSkeletonButton.disabled = !setup || !setup.sheetX || !setup.sheetY;
      }

      function getPartBounds(part, sheetWidth, sheetHeight, transformPoint) {
        const contours = part.plot_points || [];
        let minX = null;
        let minY = null;
        let maxX = null;
        let maxY = null;

        if (contours.length) {
          contours.flat().forEach((point) => {
            const baseX = (part.anchor_x ?? 0) + point[0];
            const baseY = (part.anchor_y ?? 0) + point[1];
            const { x, y } = transformPoint(baseX, baseY);
            minX = minX === null ? x : Math.min(minX, x);
            minY = minY === null ? y : Math.min(minY, y);
            maxX = maxX === null ? x : Math.max(maxX, x);
            maxY = maxY === null ? y : Math.max(maxY, y);
          });
        }

        if (minX === null || minY === null || maxX === null || maxY === null) {
          if (part.anchor_x == null || part.anchor_y == null) {
            return null;
          }
          const { x, y } = transformPoint(part.anchor_x, part.anchor_y);
          minX = Math.max(0, x - 1);
          maxX = Math.min(sheetWidth, x + 1);
          minY = Math.max(0, y - 1);
          maxY = Math.min(sheetHeight, y + 1);
        }

        return { minX, minY, maxX, maxY };
      }

      function buildSkeletonCanvas(setup, parts) {
        if (!setup || !setup.sheetX || !setup.sheetY) return null;
        const canvas = document.createElement("canvas");
        canvas.width = sheetCanvas.width;
        canvas.height = sheetCanvas.height;
        const ctx = canvas.getContext("2d");

        const padding = 24;
        const sheetWidth = setup.sheetX;
        const sheetHeight = setup.sheetY;
        const scale = Math.min(
          (canvas.width - padding * 2) / sheetWidth,
          (canvas.height - padding * 2) / sheetHeight
        );
        const originX = padding;
        const originY = padding;
        const drawWidth = sheetWidth * scale;
        const drawHeight = sheetHeight * scale;

        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#e2e8f0";
        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 2;
        ctx.fillRect(originX, originY, drawWidth, drawHeight);
        ctx.strokeRect(originX, originY, drawWidth, drawHeight);

        const flipParts180 = true;
        const transformPoint = (x, y) => {
          if (!flipParts180) {
            return { x, y };
          }
          return { x: sheetWidth - x, y: sheetHeight - y };
        };
        const toCanvas = ({ x, y }) => ({
          x: originX + x * scale,
          y: originY + (sheetHeight - y) * scale,
        });

        const splitY = sheetHeight / 2;
        const splitX = sheetWidth / 3;
        const splitX2 = splitX * 2;
        const leftMid = toCanvas({ x: 0, y: splitY });
        const rightMid = toCanvas({ x: sheetWidth, y: splitY });
        const splitLeftTop = toCanvas({ x: splitX, y: sheetHeight });
        const splitLeftBottom = toCanvas({ x: splitX, y: 0 });
        const splitRightTop = toCanvas({ x: splitX2, y: sheetHeight });
        const splitRightBottom = toCanvas({ x: splitX2, y: 0 });

        ctx.strokeStyle = "#dc2626";
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(leftMid.x, leftMid.y);
        ctx.lineTo(rightMid.x, rightMid.y);
        ctx.moveTo(splitLeftTop.x, splitLeftTop.y);
        ctx.lineTo(splitLeftBottom.x, splitLeftBottom.y);
        ctx.moveTo(splitRightTop.x, splitRightTop.y);
        ctx.lineTo(splitRightBottom.x, splitRightBottom.y);
        ctx.stroke();

        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        ctx.fillStyle = "#000";
        parts.forEach((part) => {
          const bounds = getPartBounds(part, sheetWidth, sheetHeight, transformPoint);
          if (!bounds) return;
          const topLeft = toCanvas({ x: bounds.minX, y: bounds.maxY });
          const bottomRight = toCanvas({ x: bounds.maxX, y: bounds.minY });
          const rectX = topLeft.x;
          const rectY = topLeft.y;
          const rectW = bottomRight.x - topLeft.x;
          const rectH = bottomRight.y - topLeft.y;
          if (rectW <= 0 || rectH <= 0) return;
          ctx.fillRect(rectX, rectY, rectW, rectH);
        });
        ctx.restore();

        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 2;
        ctx.strokeRect(originX, originY, drawWidth, drawHeight);

        return canvas;
      }

      function buildSkeletonSegments(sheetWidth, sheetHeight, parts) {
        const flipParts180 = true;
        const transformPoint = (x, y) => {
          if (!flipParts180) {
            return { x, y };
          }
          return { x: sheetWidth - x, y: sheetHeight - y };
        };
        const boundsList = parts
          .map((part) => getPartBounds(part, sheetWidth, sheetHeight, transformPoint))
          .filter(Boolean);
        const clearance = 0.1;
        const minSegmentLength = 0.05;
        const subtractIntervals = (rangeStart, rangeEnd, blocked) => {
          if (rangeStart >= rangeEnd) return [];
          const sorted = blocked
            .map(([start, end]) => [Math.max(rangeStart, start), Math.min(rangeEnd, end)])
            .filter(([start, end]) => end > start)
            .sort((a, b) => a[0] - b[0]);
          const merged = [];
          sorted.forEach(([start, end]) => {
            const last = merged[merged.length - 1];
            if (!last || start > last[1]) {
              merged.push([start, end]);
            } else {
              last[1] = Math.max(last[1], end);
            }
          });
          const segments = [];
          let cursor = rangeStart;
          merged.forEach(([start, end]) => {
            if (start > cursor + minSegmentLength) {
              segments.push([cursor, start]);
            }
            cursor = Math.max(cursor, end);
          });
          if (rangeEnd > cursor + minSegmentLength) {
            segments.push([cursor, rangeEnd]);
          }
          return segments;
        };
        const buildBlocked = (axisValue, axisRange, isHorizontal) => {
          return boundsList
            .filter((bounds) => {
              if (isHorizontal) {
                return axisValue >= bounds.minY - clearance && axisValue <= bounds.maxY + clearance;
              }
              return axisValue >= bounds.minX - clearance && axisValue <= bounds.maxX + clearance;
            })
            .map((bounds) => {
              if (isHorizontal) {
                return [bounds.minX - clearance, bounds.maxX + clearance];
              }
              return [bounds.minY - clearance, bounds.maxY + clearance];
            })
            .map(([start, end]) => [Math.max(axisRange[0], start), Math.min(axisRange[1], end)])
            .filter(([start, end]) => end > start);
        };
        const splitY = sheetHeight / 2;
        const splitX = sheetWidth / 3;
        const splitX2 = splitX * 2;
        const segments = [];
        [
          { orientation: "h", value: splitY, range: [0, sheetWidth] },
          { orientation: "v", value: splitX, range: [0, sheetHeight] },
          { orientation: "v", value: splitX2, range: [0, sheetHeight] },
        ].forEach((line) => {
          const isHorizontal = line.orientation === "h";
          const blocked = buildBlocked(line.value, line.range, isHorizontal);
          const subSegments = subtractIntervals(line.range[0], line.range[1], blocked);
          subSegments.forEach(([start, end]) => {
            if (isHorizontal) {
              segments.push({ start: { x: start, y: line.value }, end: { x: end, y: line.value } });
            } else {
              segments.push({ start: { x: line.value, y: start }, end: { x: line.value, y: end } });
            }
          });
        });
        return segments;
      }

      function getPartsOrderKey() {
        return lastJobId ? `cutOrder:${lastJobId}` : null;
      }

      function getContourOrderKey(partNumber) {
        return lastJobId ? `contourOrder:${lastJobId}:${partNumber}` : null;
      }

      function readStoredOrder(parts) {
        const key = getPartsOrderKey();
        if (!key) return parts.map((part) => part.part_number);
        const raw = localStorage.getItem(key);
        if (!raw) return parts.map((part) => part.part_number);
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return parts.map((part) => part.part_number);
          const partNumbers = new Set(parts.map((part) => part.part_number));
          const ordered = parsed.filter((value) => partNumbers.has(value));
          const missing = parts
            .map((part) => part.part_number)
            .filter((value) => !ordered.includes(value));
          return [...ordered, ...missing];
        } catch (err) {
          return parts.map((part) => part.part_number);
        }
      }

      function saveStoredOrder(order) {
        const key = getPartsOrderKey();
        if (!key) return;
        localStorage.setItem(key, JSON.stringify(order));
      }

      function readStoredContourOrder(partNumber) {
        const key = getContourOrderKey(partNumber);
        if (!key) return [];
        const raw = localStorage.getItem(key);
        if (!raw) return [];
        try {
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        } catch (err) {
          return [];
        }
      }

      function getOrderedParts(parts, order) {
        if (!order?.length) return parts;
        const partsByNumber = new Map(parts.map((part) => [part.part_number, part]));
        const ordered = order.map((partNumber) => partsByNumber.get(partNumber)).filter(Boolean);
        const missing = parts.filter((part) => !order.includes(part.part_number));
        return [...ordered, ...missing];
      }

      function ordersMatch(left, right) {
        if (left.length !== right.length) return false;
        return left.every((value, index) => value === right[index]);
      }

      function updateCutOrderStatus() {
        if (!cutOrderState.pendingOrder.length) {
          cutOrderStatus.textContent = "";
          return;
        }
        const matchesOriginal = ordersMatch(cutOrderState.pendingOrder, cutOrderState.originalOrder);
        cutOrderStatus.textContent = matchesOriginal
          ? "Cut order matches the original file."
          : "Cut order saved locally.";
      }

      function renderPartsOrder(parts) {
        partsOrderList.innerHTML = "";
        const hasParts = parts.length > 0;
        downloadCutOrderButton.disabled = !hasParts;
        resetCutOrderButton.disabled = !hasParts;
        if (!parts.length) {
          partsOrderList.innerHTML = "<li>No parts available.</li>";
          return;
        }
        cutOrderState.originalOrder = parts.map((part) => part.part_number);
        cutOrderState.savedOrder = readStoredOrder(parts);
        cutOrderState.pendingOrder = [...cutOrderState.savedOrder];
        const orderedParts = getOrderedParts(parts, cutOrderState.savedOrder);
        orderedParts.forEach((part) => {
          const item = document.createElement("li");
          item.className = "order-item";
          item.setAttribute("draggable", "true");
          item.dataset.partNumber = String(part.part_number);
          item.textContent = `Part ${part.part_number} — ${part.contours ?? 0} contours`;
          partsOrderList.appendChild(item);
        });
        enableDragSorting(partsOrderList, () => {
          const newOrder = Array.from(partsOrderList.querySelectorAll(".order-item")).map((item) =>
            Number(item.dataset.partNumber)
          );
          saveStoredOrder(newOrder);
          cutOrderState.pendingOrder = newOrder;
          updateCutOrderStatus();
          if (lastJob) {
            const orderedParts = getOrderedParts(lastJob.parts || [], newOrder);
            renderSheet(lastJob.setup, orderedParts);
          }
        });
        updateCutOrderStatus();
      }

      function buildContourOrders(parts) {
        const orders = {};
        parts.forEach((part) => {
          const stored = readStoredContourOrder(part.part_number);
          if (stored.length) {
            orders[part.part_number] = stored;
          }
        });
        return orders;
      }

      function getCurrentOrder() {
        return Array.from(partsOrderList.querySelectorAll(".order-item")).map((item) =>
          Number(item.dataset.partNumber)
        );
      }

      function getFilenameFromDisposition(disposition, fallbackName) {
        if (!disposition) return fallbackName;
        const match = disposition.match(/filename="([^"]+)"/i);
        return match ? match[1] : fallbackName;
      }

      downloadCutOrderButton.addEventListener("click", async () => {
        if (!lastJobId) return;
        const order = getCurrentOrder();
        if (!order.length) return;
        const contourOrders = buildContourOrders(lastJob?.parts || []);
        downloadCutOrderButton.disabled = true;
        cutOrderStatus.textContent = "Building reordered MPF...";
        try {
          const response = await fetch(`/jobs/${lastJobId}/cut-order/program`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ order, contour_orders: contourOrders }),
          });
          if (!response.ok) {
            const detail = await response.text();
            throw new Error(detail || "Unable to build reordered MPF.");
          }
          const blob = await response.blob();
          const fallbackName = `cut-order-${lastJobId}.mpf`;
          const filename = getFilenameFromDisposition(response.headers.get("Content-Disposition"), fallbackName);
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          window.URL.revokeObjectURL(url);
          cutOrderStatus.textContent = `Downloaded ${filename}.`;
        } catch (err) {
          cutOrderStatus.textContent = `Error: ${err.message}`;
        } finally {
          downloadCutOrderButton.disabled = !partsOrderList.querySelector(".order-item");
        }
      });

      resetCutOrderButton.addEventListener("click", () => {
        if (!lastJob) return;
        const key = getPartsOrderKey();
        if (key) {
          localStorage.removeItem(key);
        }
        (lastJob.parts || []).forEach((part) => {
          const contourKey = getContourOrderKey(part.part_number);
          if (contourKey) {
            localStorage.removeItem(contourKey);
          }
        });
        renderPartsOrder(lastJob.parts || []);
        renderSheet(lastJob.setup, getOrderedParts(lastJob.parts || [], cutOrderState.pendingOrder));
        cutOrderStatus.textContent = "Cut order reset to the original file.";
      });

      function enableDragSorting(listEl, onUpdate) {
        let dragging = null;
        listEl.addEventListener("dragstart", (event) => {
          const item = event.target.closest(".order-item");
          if (!item) return;
          dragging = item;
          item.classList.add("dragging");
          event.dataTransfer.effectAllowed = "move";
        });
        listEl.addEventListener("dragend", () => {
          if (dragging) {
            dragging.classList.remove("dragging");
            dragging = null;
          }
        });
        listEl.addEventListener("dragover", (event) => {
          event.preventDefault();
          if (!dragging) return;
          const target = event.target.closest(".order-item");
          if (!target || target === dragging) return;
          const rect = target.getBoundingClientRect();
          const shouldInsertAfter = event.clientY - rect.top > rect.height / 2;
          if (shouldInsertAfter) {
            target.after(dragging);
          } else {
            target.before(dragging);
          }
        });
        listEl.addEventListener("drop", (event) => {
          event.preventDefault();
          if (typeof onUpdate === "function") {
            onUpdate();
          }
        });
      }

      async function loadJob(jobId) {
        statusEl.classList.remove("hidden");
        statusEl.textContent = "Loading saved analysis...";
        resultsCard.classList.add("hidden");
        diagnosticsBody.innerHTML = "";
        rawCode.textContent = "";
        sheetHotspots = [];
        lastJobId = jobId;
        cutOrderStatus.textContent = "";
        resetCutOrderButton.disabled = true;
        downloadCutOrderButton.disabled = true;

        try {
          const response = await fetch(`/jobs/${jobId}/analysis`);
          if (!response.ok) {
            const detail = await response.text();
            throw new Error(detail || "Unable to load job analysis");
          }
          const data = await response.json();
          lastJob = data;
          renderSummary(data);
          renderStorage(data);
          renderDiagnostics(data.diagnostics);
          renderRawCode(data.raw_program || []);
          renderPartsOrder(data.parts || []);
          renderSheet(data.setup, getOrderedParts(data.parts || [], cutOrderState.pendingOrder));
          statusEl.textContent = "Saved analysis loaded.";
          resultsCard.classList.remove("hidden");
        } catch (err) {
          statusEl.textContent = `Error: ${err.message}`;
        }
      }

      sheetCanvas.addEventListener("click", (event) => {
        if (!sheetHotspots.length) return;
        const rect = sheetCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const hit = sheetHotspots.find(
          (spot) => x >= spot.x && x <= spot.x + spot.width && y >= spot.y && y <= spot.y + spot.height
        );
        if (hit) {
          window.location.href = hit.url;
        }
      });

      previewSkeletonButton.addEventListener("click", () => {
        const canvas = buildSkeletonCanvas(lastSheetSnapshot.setup, lastSheetSnapshot.parts || []);
        if (!canvas) return;
        const sheetWidth = lastSheetSnapshot.setup.sheetX;
        const sheetHeight = lastSheetSnapshot.setup.sheetY;
        const imageUrl = canvas.toDataURL("image/png");
        const popup = window.open("", "sheet-skeleton-preview", "width=900,height=700");
        if (!popup) {
          window.alert("Unable to open preview window. Please allow popups for this site.");
          return;
        }
        popup.document.title = "Sheet Skeleton Preview";
        popup.document.body.style.margin = "0";
        popup.document.body.style.display = "flex";
        popup.document.body.style.flexDirection = "column";
        popup.document.body.style.alignItems = "center";
        popup.document.body.style.justifyContent = "center";
        popup.document.body.style.background = "#f8fafc";
        popup.document.body.style.gap = "16px";
        popup.document.body.style.padding = "24px";
        const image = popup.document.createElement("img");
        image.src = imageUrl;
        image.alt = "Sheet skeleton preview";
        image.style.maxWidth = "100%";
        image.style.height = "auto";
        popup.document.body.appendChild(image);
        const gcodeBlock = popup.document.createElement("pre");
        const formatCoord = (value) => Number(value).toFixed(2);
        const splitSegments = buildSkeletonSegments(sheetWidth, sheetHeight, lastSheetSnapshot.parts || []);
        const segmentBlocks = splitSegments
          .map(
            (segment) => `G0 X${formatCoord(segment.start.x)}, Y${formatCoord(segment.start.y)}
HKCUT(0,0,0)
G1 X${formatCoord(segment.end.x)}, Y${formatCoord(segment.end.y)}
HKSTO(0,0,0)`
          )
          .join("\n\n");
        gcodeBlock.textContent = `N10001 HKSTR(1,1,0,0,0,0.0,0,0)
HKPIE(0,0,0)

${segmentBlocks}`;
        gcodeBlock.style.background = "#0f172a";
        gcodeBlock.style.color = "#f8fafc";
        gcodeBlock.style.padding = "16px 20px";
        gcodeBlock.style.borderRadius = "12px";
        gcodeBlock.style.width = "min(720px, 100%)";
        gcodeBlock.style.whiteSpace = "pre-wrap";
        gcodeBlock.style.fontFamily = "SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace";
        gcodeBlock.style.fontSize = "14px";
        gcodeBlock.style.lineHeight = "1.6";
        popup.document.body.appendChild(gcodeBlock);
      });

      const params = new URLSearchParams(window.location.search);
      const jobId = params.get("job_id");
      if (jobId) {
        loadJob(jobId);
      }
    </script>
  </body>
</html>
