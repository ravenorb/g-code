<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Job Detail</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
        background: #f8fafc;
        color: #0f172a;
      }
      .card {
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
      }
      .top-link {
        display: inline-block;
        margin-bottom: 1rem;
      }
      .sheet-canvas {
        cursor: pointer;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        background: #fff;
        width: 100%;
        max-width: 960px;
      }
      .sheet-layout {
        display: flex;
        gap: 1rem;
        align-items: flex-start;
      }
      .sheet-wrap {
        flex: 1 1 auto;
        min-width: 0;
      }
      .cut-order-frame {
        width: 220px;
        flex: 0 0 220px;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        background: #f8fafc;
        padding: 0.6rem;
        max-height: 540px;
        overflow-y: auto;
        position: sticky;
        top: 1rem;
      }
      .code-box {
        background: #0f172a;
        color: #e2e8f0;
        padding: 0.75rem;
        border-radius: 6px;
        overflow-y: auto;
        max-height: 360px;
        white-space: pre;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }
      .order-list {
        margin: 0.5rem 0 0;
        padding-left: 0;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .order-item {
        list-style: none;
        cursor: grab;
        width: fit-content;
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .order-item.dragging {
        opacity: 0.45;
      }
      .order-chip {
        border: 1px solid #94a3b8;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font-weight: 600;
        font-size: 0.9rem;
        padding: 0.3rem 0.55rem;
        min-width: 0;
      }
      .order-position {
        color: #475569;
        font-size: 0.85rem;
        min-width: 1.5rem;
        text-align: right;
      }
      button {
        padding: 0.4rem 0.75rem;
        border-radius: 4px;
        border: 1px solid #1e293b;
        background: #1e293b;
        color: #ffffff;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .muted {
        color: #475569;
      }
    </style>
  </head>
  <body>
    <h1>Job Detail</h1>
    <a class="top-link" href="/">Back to Uploaded MPF Index</a>
    <p id="status">Loading job details...</p>

    <div class="card">
      <h2>Sheet Layout</h2>
      <div class="row">
        <label><input id="show-skeleton" type="checkbox" checked /> Preview part skeleton</label>
      </div>
      <p class="muted">Click anywhere inside a part to open part detail.</p>
      <p id="sheet-info"></p>
      <div class="sheet-layout">
        <div class="sheet-wrap">
          <canvas id="sheet-canvas" class="sheet-canvas" width="960" height="540"></canvas>
        </div>
        <aside class="cut-order-frame">
          <h3>Cut Order</h3>
          <div class="row">
            <button id="save-order" type="button" disabled>Save</button>
            <button id="reset-order" type="button">Reset</button>
          </div>
          <div class="row" style="margin-top:0.4rem">
            <button id="download-order" type="button">Download</button>
          </div>
          <p id="order-status" class="muted"></p>
          <ol id="cut-order" class="order-list"></ol>
        </aside>
      </div>
    </div>

    <div class="card">
      <h2>Original File Code</h2>
      <pre id="raw-code" class="code-box"></pre>
    </div>

    <script>
      const statusEl = document.getElementById("status");
      const sheetInfo = document.getElementById("sheet-info");
      const sheetCanvas = document.getElementById("sheet-canvas");
      const cutOrderList = document.getElementById("cut-order");
      const rawCode = document.getElementById("raw-code");
      const showSkeletonCheckbox = document.getElementById("show-skeleton");
      const saveOrderButton = document.getElementById("save-order");
      const resetOrderButton = document.getElementById("reset-order");
      const orderStatus = document.getElementById("order-status");
      const downloadOrderButton = document.getElementById("download-order");
      let jobData = null;
      let pendingOrder = [];
      let clickableParts = [];
      const CONTOUR_CLOSE_EPSILON = 0.001;

      function contourIsClosed(contour) {
        if (!Array.isArray(contour) || contour.length < 2) {
          return false;
        }
        const first = contour[0] || [];
        const last = contour[contour.length - 1] || [];
        const firstX = Number(first[0] || 0);
        const firstY = Number(first[1] || 0);
        const lastX = Number(last[0] || 0);
        const lastY = Number(last[1] || 0);
        return Math.hypot(firstX - lastX, firstY - lastY) <= CONTOUR_CLOSE_EPSILON;
      }

      function getJobId() {
        const parts = window.location.pathname.split("/").filter(Boolean);
        return parts.length >= 2 ? decodeURIComponent(parts[1]) : null;
      }

      function partOrderKey(jobId) {
        return `partOrder:${jobId}`;
      }

      function contourOrderStorageKey(jobId, partNumber) {
        return `contourOrder:${jobId}:${partNumber}`;
      }

      function readPartOrder(jobId, parts) {
        const fallback = parts.map((part) => part.part_number);
        const raw = localStorage.getItem(partOrderKey(jobId));
        if (!raw) return fallback;
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return fallback;
          const available = new Set(fallback);
          const ordered = parsed.filter((partNumber) => available.has(partNumber));
          const missing = fallback.filter((partNumber) => !ordered.includes(partNumber));
          return [...ordered, ...missing];
        } catch (_err) {
          return fallback;
        }
      }

      function readContourOrders(jobId, parts) {
        const orders = {};
        parts.forEach((part) => {
          const raw = localStorage.getItem(contourOrderStorageKey(jobId, part.part_number));
          if (!raw) return;
          try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              orders[part.part_number] = parsed.map((entry) => String(entry));
            }
          } catch (_err) {
            // ignore malformed local storage values
          }
        });
        return orders;
      }

      function reorderParts(parts, order) {
        const map = new Map(parts.map((part) => [part.part_number, part]));
        return order.map((partNumber) => map.get(partNumber)).filter(Boolean);
      }

      function enableDragSorting(listEl, onUpdate) {
        let dragging = null;
        listEl.addEventListener("dragstart", (event) => {
          const item = event.target.closest(".order-item");
          if (!item) return;
          dragging = item;
          item.classList.add("dragging");
          event.dataTransfer.effectAllowed = "move";
        });
        listEl.addEventListener("dragend", () => {
          if (dragging) {
            dragging.classList.remove("dragging");
            dragging = null;
          }
        });
        listEl.addEventListener("dragover", (event) => {
          event.preventDefault();
          if (!dragging) return;
          const target = event.target.closest(".order-item");
          if (!target || target === dragging) return;
          const rect = target.getBoundingClientRect();
          const shouldInsertAfter = event.clientY - rect.top > rect.height / 2;
          if (shouldInsertAfter) {
            target.after(dragging);
          } else {
            target.before(dragging);
          }
        });
        listEl.addEventListener("drop", (event) => {
          event.preventDefault();
          if (typeof onUpdate === "function") {
            onUpdate();
          }
        });
      }

      function pointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i, i += 1) {
          const xi = Number(polygon[i][0] || 0);
          const yi = Number(polygon[i][1] || 0);
          const xj = Number(polygon[j][0] || 0);
          const yj = Number(polygon[j][1] || 0);
          const intersects = yi > point.y !== yj > point.y && point.x < ((xj - xi) * (point.y - yi)) / ((yj - yi) || Number.EPSILON) + xi;
          if (intersects) inside = !inside;
        }
        return inside;
      }

      function renderSheet(job, orderedParts) {
        const ctx = sheetCanvas.getContext("2d");
        const setup = job.setup || {};
        const sheetX = Number(setup.sheetX || 0);
        const sheetY = Number(setup.sheetY || 0);

        ctx.clearRect(0, 0, sheetCanvas.width, sheetCanvas.height);
        if (!sheetX || !sheetY) {
          sheetInfo.textContent = "Sheet dimensions not found in file setup.";
          return;
        }

        const margin = 20;
        const availableW = sheetCanvas.width - margin * 2;
        const availableH = sheetCanvas.height - margin * 2;
        const scale = Math.min(availableW / sheetX, availableH / sheetY);
        const drawW = sheetX * scale;
        const drawH = sheetY * scale;
        const originX = (sheetCanvas.width - drawW) / 2;
        const originY = (sheetCanvas.height - drawH) / 2;

        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 2;
        ctx.strokeRect(originX, originY, drawW, drawH);

        const showSkeleton = showSkeletonCheckbox.checked;
        clickableParts = [];

        if (showSkeleton) {
          ctx.save();
          ctx.fillStyle = "rgba(148, 163, 184, 0.25)";
          ctx.beginPath();
          orderedParts.forEach((part) => {
            const x = Number(part.anchor_x || 0);
            const y = Number(part.anchor_y || 0);
            if (!Array.isArray(part.plot_points)) return;
            part.plot_points.forEach((contour) => {
              if (!Array.isArray(contour) || !contour.length || !contourIsClosed(contour)) return;
              ctx.moveTo(originX + (x + Number(contour[0][0] || 0)) * scale, originY + (y + Number(contour[0][1] || 0)) * scale);
              contour.forEach((point) => {
                const cx = originX + (x + Number(point[0] || 0)) * scale;
                const cy = originY + (y + Number(point[1] || 0)) * scale;
                ctx.lineTo(cx, cy);
              });
              ctx.closePath();
            });
          });
          ctx.fill();
          ctx.restore();
        }

        orderedParts.forEach((part, index) => {
          const x = Number(part.anchor_x || 0);
          const y = Number(part.anchor_y || 0);
          const px = originX + x * scale;
          const py = originY + y * scale;
          const regions = [];

          if (Array.isArray(part.plot_points) && part.plot_points.length) {
            part.plot_points.forEach((contour) => {
              if (!Array.isArray(contour) || !contour.length || !contourIsClosed(contour)) return;
              regions.push(
                contour.map((point) => [
                  originX + (x + Number(point[0] || 0)) * scale,
                  originY + (y + Number(point[1] || 0)) * scale,
                ])
              );
            });
          }

          if (showSkeleton && Array.isArray(part.plot_points) && part.plot_points.length) {
            ctx.strokeStyle = "#2563eb";
            ctx.lineWidth = 1.5;
            part.plot_points.forEach((contour) => {
              if (!Array.isArray(contour) || !contour.length) return;
              const isClosedContour = contourIsClosed(contour);
              ctx.beginPath();
              contour.forEach((point, pointIndex) => {
                const cx = originX + (x + Number(point[0] || 0)) * scale;
                const cy = originY + (y + Number(point[1] || 0)) * scale;
                if (pointIndex === 0) {
                  ctx.moveTo(cx, cy);
                } else {
                  ctx.lineTo(cx, cy);
                }
              });
              if (isClosedContour) {
                ctx.closePath();
                regions.push(
                  contour.map((point) => [
                    originX + (x + Number(point[0] || 0)) * scale,
                    originY + (y + Number(point[1] || 0)) * scale,
                  ])
                );
              }
              ctx.stroke();
            });
          }

          clickableParts.push({ partNumber: part.part_number, regions, x: px, y: py });
          ctx.fillStyle = "#2563eb";
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#0f172a";
          ctx.font = "12px Arial";
          const labelW = ctx.measureText(label).width;
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.fillRect(px - labelW / 2 - 4, py - 10, labelW + 8, 14);
          ctx.fillStyle = "#0f172a";
          ctx.fillText(label, px - labelW / 2, py);
        });

        const mode = showSkeleton ? "skeleton" : "anchors";
        sheetInfo.textContent = `Sheet: ${sheetX} x ${sheetY} • Parts: ${orderedParts.length} • View: ${mode}`;
      }

      function renderCutOrder(jobId, parts, order) {
        cutOrderList.innerHTML = "";
        const orderedParts = reorderParts(parts, order);
        orderedParts.forEach((part, index) => {
          const li = document.createElement("li");
          li.className = "order-item";
          li.setAttribute("draggable", "true");
          li.dataset.partNumber = String(part.part_number);
          li.title = `Part ${part.part_number} • line ${part.part_line ?? "?"} • contours ${part.contours ?? "?"} • position ${index + 1}`;

          const position = document.createElement("span");
          position.className = "order-position";
          position.textContent = `${index + 1}.`;

          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = "order-chip";
          chip.textContent = String(part.part_number);
          chip.addEventListener("click", () => {
            window.location.href = `/jobs/${encodeURIComponent(jobId)}/parts/${part.part_number}/view`;
          });

          li.appendChild(position);
          li.appendChild(chip);
          cutOrderList.appendChild(li);
        });

        enableDragSorting(cutOrderList, () => {
          pendingOrder = Array.from(cutOrderList.querySelectorAll(".order-item")).map((item) =>
            Number(item.dataset.partNumber)
          );
          saveOrderButton.disabled = false;
          orderStatus.textContent = "Unsaved cut-order changes.";
          renderSheet(jobData, reorderParts(parts, pendingOrder));
        });
      }

      async function downloadReorderedProgram(jobId) {
        if (!jobData) return;
        const contourOrders = readContourOrders(jobId, jobData.parts || []);
        const response = await fetch(`/jobs/${encodeURIComponent(jobId)}/cut-order/program`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            order: pendingOrder,
            contour_orders: contourOrders,
          }),
        });
        if (!response.ok) {
          throw new Error("Unable to build reordered program");
        }
        const blob = await response.blob();
        const href = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const disposition = response.headers.get("Content-Disposition") || "";
        const match = disposition.match(/filename="([^"]+)"/i);
        link.download = match ? match[1] : `${jobId}_cut_order.mpf`;
        link.href = href;
        link.click();
        URL.revokeObjectURL(href);
      }

      async function loadJob() {
        const jobId = getJobId();
        if (!jobId) {
          statusEl.textContent = "No job id found in URL.";
          return;
        }
        try {
          const response = await fetch(`/jobs/${encodeURIComponent(jobId)}/analysis`);
          if (!response.ok) {
            throw new Error("Unable to load job analysis");
          }
          const job = await response.json();
          jobData = job;

          const parts = job.parts || [];
          pendingOrder = readPartOrder(jobId, parts);
          renderCutOrder(jobId, parts, pendingOrder);
          renderSheet(job, reorderParts(parts, pendingOrder));

          rawCode.textContent = Array.isArray(job.raw_program) ? job.raw_program.join("\n") : "";
          saveOrderButton.disabled = true;
          orderStatus.textContent = "";
          statusEl.textContent = `Showing ${jobId} (${parts.length} part(s)).`;

          saveOrderButton.onclick = () => {
            localStorage.setItem(partOrderKey(jobId), JSON.stringify(pendingOrder));
            saveOrderButton.disabled = true;
            orderStatus.textContent = "Part order saved in browser storage.";
          };

          resetOrderButton.onclick = () => {
            localStorage.removeItem(partOrderKey(jobId));
            pendingOrder = parts.map((part) => part.part_number);
            renderCutOrder(jobId, parts, pendingOrder);
            renderSheet(job, reorderParts(parts, pendingOrder));
            saveOrderButton.disabled = true;
            orderStatus.textContent = "Part order reset.";
          };

          downloadOrderButton.onclick = async () => {
            try {
              await downloadReorderedProgram(jobId);
              orderStatus.textContent = "Downloaded reordered program.";
            } catch (error) {
              orderStatus.textContent = `Error: ${error.message}`;
            }
          };
        } catch (error) {
          statusEl.textContent = `Error: ${error.message}`;
        }
      }

      showSkeletonCheckbox.addEventListener("change", () => {
        if (!jobData) return;
        renderSheet(jobData, reorderParts(jobData.parts || [], pendingOrder));
      });


      sheetCanvas.addEventListener("click", (event) => {
        const jobId = getJobId();
        if (!jobId || !clickableParts.length) return;
        const rect = sheetCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const hit = clickableParts.find((part) => part.regions.some((polygon) => pointInPolygon({ x, y }, polygon)));
        if (hit) {
          window.location.href = `/jobs/${encodeURIComponent(jobId)}/parts/${hit.partNumber}/view`;
          return;
        }

        let closest = null;
        let bestDist = Number.POSITIVE_INFINITY;
        clickableParts.forEach((part) => {
          const dist = Math.hypot((part.x || 0) - x, (part.y || 0) - y);
          if (dist < bestDist) {
            bestDist = dist;
            closest = part;
          }
        });
        if (closest && bestDist <= 18) {
          window.location.href = `/jobs/${encodeURIComponent(jobId)}/parts/${closest.partNumber}/view`;
        }
      });

      loadJob();
    </script>
  </body>
</html>
