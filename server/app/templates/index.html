<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cut Order Plugin</title>
    <style>
      :root { color-scheme: light; }
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #f8fafc;
        color: #0f172a;
        height: 100vh;
        overflow: hidden;
      }
      .menu-bar {
        height: 56px;
        display: flex;
        align-items: center;
        gap: 0.65rem;
        padding: 0 0.8rem;
        border-bottom: 1px solid #cbd5e1;
        background: #fff;
      }
      .menu-bar button {
        height: 34px;
        border: 1px solid #1e293b;
        background: #1e293b;
        color: #fff;
        border-radius: 6px;
        padding: 0 0.8rem;
        font-size: 0.8rem;
        cursor: pointer;
      }
      .menu-bar button:disabled { opacity: 0.5; cursor: not-allowed; }
      #menu-status { color: #475569; font-size: 0.9rem; margin-left: auto; }
      .main {
        display: flex;
        height: calc(100vh - 56px);
      }
      .canvas-pane {
        flex: 1;
        padding: 0.7rem;
        overflow: hidden;
      }
      #main-canvas {
        width: 100%;
        height: 100%;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        background: white;
      }
      .side-pane {
        width: 350px;
        min-width: 350px;
        border-left: 1px solid #cbd5e1;
        background: #fff;
        display: flex;
        flex-direction: column;
      }
      .side-list {
        flex: 1;
        overflow-y: auto;
        margin: 0;
        padding: 0.6rem;
        list-style: none;
      }
      .order-item {
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        padding: 0.5rem 0.55rem;
        margin-bottom: 0.45rem;
        cursor: grab;
        background: #f8fafc;
        user-select: none;
      }
      .order-item.dragging { opacity: 0.45; }
      .changed-from { color: #dc2626; font-weight: 700; }
      .extra-wrap { border-top: 1px solid #e2e8f0; padding: 0.55rem; }
      .extra-wrap label { display: block; font-size: 0.8rem; margin-bottom: 0.35rem; }
      .extra-row { display: flex; gap: 0.4rem; }
      .extra-row input {
        flex: 1;
        min-width: 0;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        height: 34px;
        padding: 0 0.5rem;
      }
      .extra-row button {
        border: 1px solid #1e293b;
        background: #1e293b;
        color: #fff;
        border-radius: 6px;
        padding: 0 0.7rem;
      }
      .hidden { display: none; }
      #upload-form { display: none; }
    </style>
  </head>
  <body>
    <div class="menu-bar" id="menu-bar"></div>
    <div class="main">
      <div class="canvas-pane">
        <canvas id="main-canvas" width="1300" height="850"></canvas>
      </div>
      <aside class="side-pane">
        <ul id="order-list" class="side-list"></ul>
        <div id="extra-wrap" class="extra-wrap hidden">
          <label for="extra-input">EXTRA CONTOURS (part.contour, part.contour):</label>
          <div class="extra-row">
            <input id="extra-input" type="text" />
            <button id="apply-extra" type="button">Apply</button>
          </div>
        </div>
      </aside>
    </div>

    <form id="upload-form">
      <input id="file" type="file" name="file" accept=".gcode,.txt,.mpf,.nc,.tap" />
      <textarea id="description" name="description"></textarea>
    </form>

    <script>
      const canvas = document.getElementById("main-canvas");
      const ctx = canvas.getContext("2d");
      const menuBar = document.getElementById("menu-bar");
      const menuStatus = document.createElement("span");
      menuStatus.id = "menu-status";
      const orderList = document.getElementById("order-list");
      const extraWrap = document.getElementById("extra-wrap");
      const extraInput = document.getElementById("extra-input");
      const applyExtraButton = document.getElementById("apply-extra");
      const uploadForm = document.getElementById("upload-form");
      const fileInput = document.getElementById("file");
      const descriptionInput = document.getElementById("description");

      const state = {
        mode: "sheet",
        jobId: null,
        job: null,
        hotspots: [],
        selectedPart: null,
        partData: null,
        partOrder: [],
        originalPartOrder: [],
        contourOrder: [],
        originalContourOrder: [],
        showSkeleton: false,
        skeletonApplied: false,
      };

      function partOrderKey() { return `cutOrder:${state.jobId}`; }
      function contourOrderKey(partNumber) { return `contourOrder:${state.jobId}:${partNumber}`; }

      function readStoredOrder(parts) {
        const fallback = parts.map((p) => p.part_number);
        const raw = localStorage.getItem(partOrderKey());
        if (!raw) return fallback;
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return fallback;
          const available = new Set(fallback);
          const clean = parsed.filter((value) => available.has(value));
          return [...clean, ...fallback.filter((n) => !clean.includes(n))];
        } catch (_err) {
          return fallback;
        }
      }

      function readStoredContours(partNumber, contours) {
        const fallback = contours.map((_, idx) => String(idx + 1));
        const raw = localStorage.getItem(contourOrderKey(partNumber));
        if (!raw) return fallback;
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return fallback;
          const available = new Set(fallback);
          const clean = parsed.filter((value) => available.has(String(value))).map(String);
          return [...clean, ...fallback.filter((id) => !clean.includes(id))];
        } catch (_err) {
          return fallback;
        }
      }

      function savePartOrder() {
        localStorage.setItem(partOrderKey(), JSON.stringify(state.partOrder));
        menuStatus.textContent = "Part order saved.";
      }

      function saveContourOrder() {
        if (!state.selectedPart) return;
        localStorage.setItem(contourOrderKey(state.selectedPart.part_number), JSON.stringify(state.contourOrder));
        menuStatus.textContent = "Cut order saved.";
      }

      function getOrderedParts() {
        const partMap = new Map((state.job?.parts || []).map((part) => [part.part_number, part]));
        return state.partOrder.map((id) => partMap.get(id)).filter(Boolean);
      }

      function renderMenu() {
        menuBar.innerHTML = "";
        const addButton = (label, onClick, disabled = false) => {
          const button = document.createElement("button");
          button.type = "button";
          button.textContent = label;
          button.disabled = disabled;
          button.addEventListener("click", onClick);
          menuBar.appendChild(button);
          return button;
        };

        if (state.mode === "sheet") {
          addButton("RESET ORDER", () => {
            if (!state.job) return;
            localStorage.removeItem(partOrderKey());
            state.partOrder = [...state.originalPartOrder];
            state.skeletonApplied = false;
            renderSheetMode();
            menuStatus.textContent = "Order reset.";
          }, !state.job);
          addButton("SAVE ORDER", savePartOrder, !state.job);
          addButton("PREVIEW SKELETON CUT", () => {
            state.showSkeleton = !state.showSkeleton;
            drawSheet();
            menuStatus.textContent = state.showSkeleton ? "Skeleton preview enabled." : "Skeleton preview disabled.";
          }, !state.job);
          addButton("APPLY SKELETON CUT", async () => {
            state.skeletonApplied = true;
            await downloadCutOrderProgram();
            menuStatus.textContent = "Applied skeleton cut and downloaded program.";
          }, !state.job);
          if (!new URLSearchParams(window.location.search).get("job_id")) {
            addButton("UPLOAD", () => fileInput.click());
          }
        } else {
          addButton("RESET ORDER", () => {
            if (!state.partData) return;
            localStorage.removeItem(contourOrderKey(state.selectedPart.part_number));
            state.contourOrder = [...state.originalContourOrder];
            renderPartMode();
            menuStatus.textContent = "Contour order reset.";
          }, !state.partData);
          addButton("SAVE CUT ORDER", saveContourOrder, !state.partData);
          addButton("GENERATE STAND ALONE", downloadStandalonePart, !state.partData);
          addButton("BACK TO SHEET", () => {
            state.mode = "sheet";
            state.selectedPart = null;
            state.partData = null;
            renderSheetMode();
          });
        }
        menuBar.appendChild(menuStatus);
      }

      function drawSheet() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.hotspots = [];
        const setup = state.job?.setup || {};
        const orderedParts = getOrderedParts();
        const sheetW = Number(setup.sheetX || 0);
        const sheetH = Number(setup.sheetY || 0);
        if (!sheetW || !sheetH) return;

        const rotatedW = sheetH;
        const rotatedH = sheetW;
        const padding = 26;
        const scale = Math.min((canvas.width - 2 * padding) / rotatedW, (canvas.height - 2 * padding) / rotatedH);
        const originX = (canvas.width - rotatedW * scale) / 2;
        const originY = (canvas.height - rotatedH * scale) / 2;

        const toCanvas = (x, y) => {
          const xRot = -y + sheetH;
          const yRot = x;
          return {
            x: originX + xRot * scale,
            y: originY + (rotatedH - yRot) * scale,
          };
        };

        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 2;
        ctx.strokeRect(originX, originY, rotatedW * scale, rotatedH * scale);

        orderedParts.forEach((part, idx) => {
          const contours = part.plot_points || [];
          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 1.2;

          contours.forEach((contour) => {
            if (!Array.isArray(contour) || !contour.length) return;
            ctx.beginPath();
            contour.forEach((point, pointIdx) => {
              const baseX = (part.anchor_x || 0) + Number(point[0] || 0);
              const baseY = (part.anchor_y || 0) + Number(point[1] || 0);
              const p = toCanvas(baseX, baseY);
              minX = Math.min(minX, p.x);
              minY = Math.min(minY, p.y);
              maxX = Math.max(maxX, p.x);
              maxY = Math.max(maxY, p.y);
              if (pointIdx === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
          });

          if (state.showSkeleton && minX < Infinity) {
            ctx.fillStyle = "rgba(148, 163, 184, 0.18)";
            ctx.fillRect(minX, minY, Math.max(12, maxX - minX), Math.max(12, maxY - minY));
          }

          if (minX < Infinity) {
            state.hotspots.push({
              x: minX,
              y: minY,
              width: Math.max(12, maxX - minX),
              height: Math.max(12, maxY - minY),
              partNumber: part.part_number,
            });
          }

          if (part.anchor_x != null && part.anchor_y != null) {
            const labelPoint = toCanvas(part.anchor_x, part.anchor_y);
            ctx.fillStyle = "#0f172a";
            ctx.font = "12px Arial";
            ctx.fillText(String(idx + 1), labelPoint.x + 6, labelPoint.y - 6);
          }
        });
      }

      function renderOrderList(modeItems, getLabelHtml) {
        orderList.innerHTML = "";
        modeItems.forEach((entry, index) => {
          const li = document.createElement("li");
          li.className = "order-item";
          li.setAttribute("draggable", "true");
          li.dataset.id = String(entry.id);
          li.innerHTML = getLabelHtml(entry, index);
          orderList.appendChild(li);
        });
        enableDragSorting(orderList);
      }

      function renderSheetMode() {
        extraWrap.classList.add("hidden");
        renderMenu();
        const originalIndex = new Map(state.originalPartOrder.map((id, index) => [id, index + 1]));
        const items = state.partOrder.map((partNumber, index) => ({ id: partNumber, index }));
        renderOrderList(items, (entry, index) => {
          const oldPos = originalIndex.get(entry.id);
          const changed = oldPos !== index + 1;
          const changedSuffix = changed ? ` <span class="changed-from">(${oldPos})</span>` : "";
          return `PART ${entry.id}${changedSuffix}`;
        });
        drawSheet();
      }

      async function loadPart(partNumber, extra = "") {
        const params = new URLSearchParams();
        if (extra) params.set("extra_contours", extra);
        const query = params.toString() ? `?${params.toString()}` : "";
        const response = await fetch(`/jobs/${encodeURIComponent(state.jobId)}/parts/${partNumber}${query}`);
        if (!response.ok) throw new Error("Unable to load part");
        state.partData = await response.json();
        const contours = state.partData.plot_contours || state.partData.plot_points || [];
        state.originalContourOrder = contours.map((_, index) => String(index + 1));
        state.contourOrder = readStoredContours(partNumber, contours);
      }

      function drawPart() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const contoursRaw = state.partData?.plot_contours || state.partData?.plot_points || [];
        const contourMap = new Map();
        contoursRaw.forEach((contour, index) => contourMap.set(String(index + 1), contour.points || contour));
        const ordered = state.contourOrder.map((id) => contourMap.get(id)).filter(Boolean);
        const points = ordered.flat();
        if (!points.length) return;

        let minX = Infinity; let minY = Infinity; let maxX = -Infinity; let maxY = -Infinity;
        points.forEach((point) => {
          const x = Number(point[0] || 0);
          const y = Number(point[1] || 0);
          minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
        });
        const width = Math.max(1, maxX - minX);
        const height = Math.max(1, maxY - minY);
        const rotW = height;
        const rotH = width;
        const pad = 28;
        const scale = Math.min((canvas.width - 2 * pad) / rotW, (canvas.height - 2 * pad) / rotH);
        const originX = (canvas.width - rotW * scale) / 2;
        const originY = (canvas.height - rotH * scale) / 2;

        const toCanvas = (x, y) => {
          const nx = x - minX;
          const ny = y - minY;
          const xRot = -ny + height;
          const yRot = nx;
          return { x: originX + xRot * scale, y: originY + (rotH - yRot) * scale };
        };

        ctx.strokeStyle = "#2563eb";
        ctx.lineWidth = 1.5;
        ordered.forEach((contour, idx) => {
          if (!Array.isArray(contour) || !contour.length) return;
          ctx.beginPath();
          contour.forEach((point, pIdx) => {
            const p = toCanvas(Number(point[0] || 0), Number(point[1] || 0));
            if (pIdx === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
          });
          ctx.stroke();
          const labelPoint = toCanvas(Number(contour[0][0] || 0), Number(contour[0][1] || 0));
          ctx.fillStyle = "#0f172a";
          ctx.font = "11px Arial";
          ctx.fillText(String(idx + 1), labelPoint.x + 4, labelPoint.y - 4);
        });
      }

      function renderPartMode() {
        extraWrap.classList.remove("hidden");
        renderMenu();
        const originalIndex = new Map(state.originalContourOrder.map((id, idx) => [id, idx + 1]));
        const items = state.contourOrder.map((id) => ({ id }));
        renderOrderList(items, (entry, index) => {
          const oldPos = originalIndex.get(entry.id);
          const changed = oldPos !== index + 1;
          const changedSuffix = changed ? ` <span class="changed-from">(${oldPos})</span>` : "";
          return `CONT ${index + 1}${changedSuffix}`;
        });
        drawPart();
      }

      async function downloadStandalonePart() {
        if (!state.selectedPart) return;
        const value = cleanExtraContours(extraInput.value);
        const params = new URLSearchParams();
        if (value) params.set("extra_contours", value);
        const query = params.toString() ? `?${params.toString()}` : "";
        const response = await fetch(`/jobs/${encodeURIComponent(state.jobId)}/parts/${state.selectedPart.part_number}/program${query}`);
        if (!response.ok) {
          menuStatus.textContent = "Unable to generate stand alone file.";
          return;
        }
        const blob = await response.blob();
        const href = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const disposition = response.headers.get("Content-Disposition") || "";
        const match = disposition.match(/filename="([^"]+)"/i);
        link.download = match ? match[1] : `part-${state.selectedPart.part_number}.mpf`;
        link.href = href;
        link.click();
        URL.revokeObjectURL(href);
      }

      function cleanExtraContours(raw) {
        return raw
          .split(",")
          .map((token) => token.trim())
          .filter(Boolean)
          .join(",");
      }

      function enableDragSorting(listEl) {
        let dragging = null;
        listEl.ondragstart = (event) => {
          const item = event.target.closest(".order-item");
          if (!item) return;
          dragging = item;
          dragging.classList.add("dragging");
          event.dataTransfer.effectAllowed = "move";
        };
        listEl.ondragend = () => { if (dragging) dragging.classList.remove("dragging"); dragging = null; };
        listEl.ondragover = (event) => {
          event.preventDefault();
          if (!dragging) return;
          const target = event.target.closest(".order-item");
          if (!target || target === dragging) return;
          const rect = target.getBoundingClientRect();
          const after = event.clientY - rect.top > rect.height / 2;
          if (after) target.after(dragging); else target.before(dragging);
        };
        listEl.ondrop = (event) => {
          event.preventDefault();
          const ids = Array.from(orderList.querySelectorAll(".order-item")).map((item) => item.dataset.id);
          if (state.mode === "sheet") {
            state.partOrder = ids.map(Number);
            renderSheetMode();
            menuStatus.textContent = "Unsaved part-order changes.";
          } else {
            state.contourOrder = ids;
            renderPartMode();
            menuStatus.textContent = "Unsaved contour changes.";
          }
        };
      }

      function buildSkeletonSegments() {
        const setup = state.job?.setup || {};
        const w = Number(setup.sheetX || 0);
        const h = Number(setup.sheetY || 0);
        if (!w || !h) return [];
        return [
          { start: { x: 0, y: h / 2 }, end: { x: w, y: h / 2 } },
          { start: { x: w / 2, y: 0 }, end: { x: w / 2, y: h } },
        ];
      }

      async function downloadCutOrderProgram() {
        if (!state.jobId) return;
        const contourOrders = {};
        (state.job?.parts || []).forEach((part) => {
          const raw = localStorage.getItem(contourOrderKey(part.part_number));
          if (raw) {
            try {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed) && parsed.length) contourOrders[part.part_number] = parsed;
            } catch (_err) {
              // ignore malformed stored contour order
            }
          }
        });
        const response = await fetch(`/jobs/${encodeURIComponent(state.jobId)}/cut-order/program`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ order: state.partOrder, contour_orders: contourOrders }),
        });
        if (!response.ok) {
          menuStatus.textContent = "Unable to build reordered program.";
          return;
        }
        let text = await response.text();
        if (state.skeletonApplied) {
          const segments = buildSkeletonSegments();
          const toLine = (segment) => `G0 X${segment.start.x.toFixed(2)}, Y${segment.start.y.toFixed(2)}\nHKCUT(0,0,0)\nG1 X${segment.end.x.toFixed(2)}, Y${segment.end.y.toFixed(2)}\nHKSTO(0,0,0)`;
          text += `\n\nN10001 HKSTR(1,1,0,0,0,0.0,0,0)\nHKPIE(0,0,0)\n${segments.map(toLine).join("\n")}`;
        }
        const blob = new Blob([text], { type: "text/plain" });
        const href = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = `cut-order-${state.jobId}.mpf`;
        link.href = href;
        link.click();
        URL.revokeObjectURL(href);
      }

      async function loadJob(jobId) {
        const response = await fetch(`/jobs/${encodeURIComponent(jobId)}/analysis`);
        if (!response.ok) {
          menuStatus.textContent = "Unable to load job analysis.";
          return;
        }
        state.jobId = jobId;
        state.job = await response.json();
        state.originalPartOrder = (state.job.parts || []).map((part) => part.part_number);
        state.partOrder = readStoredOrder(state.job.parts || []);
        state.mode = "sheet";
        renderSheetMode();
        renderMenu();
        menuStatus.textContent = `Loaded ${jobId}`;
      }

      fileInput.addEventListener("change", () => {
        if (!fileInput.files.length) return;
        const description = window.prompt("Describe the file contents (optional):", "");
        descriptionInput.value = description ? description.trim() : "";
        uploadForm.requestSubmit();
      });

      uploadForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!fileInput.files.length) return;
        const formData = new FormData();
        formData.append("file", fileInput.files[0]);
        formData.append("description", descriptionInput.value || "");
        const response = await fetch("/upload", { method: "POST", body: formData });
        if (!response.ok) {
          menuStatus.textContent = "Upload failed.";
          return;
        }
        const payload = await response.json();
        fileInput.value = "";
        await loadJob(payload.job_id);
      });

      canvas.addEventListener("click", async (event) => {
        if (state.mode !== "sheet") return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const hit = state.hotspots.find((spot) => x >= spot.x && x <= spot.x + spot.width && y >= spot.y && y <= spot.y + spot.height);
        if (!hit) return;
        state.selectedPart = (state.job.parts || []).find((part) => part.part_number === hit.partNumber) || null;
        if (!state.selectedPart) return;
        await loadPart(hit.partNumber, cleanExtraContours(extraInput.value || ""));
        state.mode = "part";
        renderPartMode();
      });

      applyExtraButton.addEventListener("click", async () => {
        if (!state.selectedPart) return;
        const cleaned = cleanExtraContours(extraInput.value);
        extraInput.value = cleaned;
        await loadPart(state.selectedPart.part_number, cleaned);
        renderPartMode();
      });

      const params = new URLSearchParams(window.location.search);
      const preloadedJob = params.get("job_id");
      if (preloadedJob) {
        loadJob(preloadedJob);
      } else {
        renderMenu();
        menuStatus.textContent = "Upload to begin.";
      }

    </script>
  </body>
</html>
